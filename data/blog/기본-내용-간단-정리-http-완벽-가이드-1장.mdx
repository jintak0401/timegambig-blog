---
title: 기본 내용 간단 정리 - HTTP 완벽 가이드 1장
date: '2022-11-23T05:07:37.715Z'
lastmod: '2022-11-23T05:07:37.715Z'
tags: ['HTTP','네트워크']
draft: false
series: HTTP 완벽 가이드
summary: HTTP 완벽 가이드 1장을 간단하게 정리한 내용입니다.
images: ['/static/images/blog/http-완벽-가이드/cover.webp']
layout: PostLayout
---

## HTTP

HTTP란 Hypertext Transfer Protocol의 약자로 신뢰성이 보장된 프로토콜입니다.^[프로토콜이란
컴퓨터간 어떻게 데이터를 교환할 것인지 미리 정의한 형식이나 약속을 말합니다.]

## 리소스

인터넷을 하다보면 보게 되는 모든 화면들이나, 텍스트 파일, 이미지 파일, HTML 파일, 동영상 파일 등
접하는 모든 것들이 모두 웹 리소스입니다. HTTP 프로토콜은 결국 이런 리소스들을 효율적으로 주고 받기
위해 정의된 규약입니다.

### 미디어 타입

인터넷에는 너무나도 많은 종류의 리소스들이 있기 때문에, HTTP는 웹에서 전송되는 객체 각각에
MIME 타입이라는 데이터 포맷 라벨을 붙입니다. MIME이란 Multipurpose Internet Mail Extensions의
약자로, 원래 각기 다른 전자메일 시스템 사이에서 메일이 오갈 때 겪는 문제점을 해결하기 위해 설계되었습니다.
MIME이 이메일에서 올바르게 잘 동작했기 때문에, HTTP에서도 멀티미디어 콘텐츠를 기술하고 라벨을
붙이기 위해 채택되었습니다.

MIME 타입은 사선(/)을 기준으로 주 타입(primary objedct type)과 부 타입(specific subtype)으로
나뉩니다. 예를들면 다음과 같습니다.

* HTML: text/html
* ASCII: text/plain
* JPEG: image/jpeg
* GIF: image/gif
* 애플 퀵타입 동영상: video/quicktime
* PowerPoint: application/vnd.ms-powerpoint

### URI

과일 가게에 가서 사과를 달라고 하는 것처럼, 리소스를 요청하려면 서버에게 "어떤 리소스를" 달라고
요청할 수 있어야 합니다. 즉, 우리가 원하는 리소스를 명확하게 지목할 수 있어야 합니다. 이를 위해
리소스마다 URI(통합 자원 식별자)가 존재하여, 이를 이용하여 리소스를 고유하게 식별하고
위치를 지정할 수 있습니다. 그리고 URI는 URL과 URN으로 나눌 수 있습니다.

<Alert type="info">
  ![URI는 URL과 URN으로 구성되어있습니다.](/static/images/blog/http-완벽-가이드/01/uri.webp)

  오늘날 대부분의 URI는 URL입니다.
</Alert>

#### URL

URL(Uniform Resource Locator)은 특정 서버의 리소스에 대한 구체적인 위치를 서술합니다.
예를들어 [https://timegambit.com/static/images/logo.png](https://timegambit.com/static/images/logo.png)
라는 URL에 대해서 생각해보겠습니다.

* 첫 번째 부분은 scheme(스킴)으로 프로토콜을 서술합니다. 이 경우에는 https 프로토콜입니다.
* timegambit.com은 서버의 인터넷 주소입니다.
* /static/images/logo.png는 웹 서버의 리소스 위치를 가리킵니다. /static/images라는 폴더에 logo.png를 요청하고 있네요.

좀 더 자세한 설명은 2장에서 설명하겠습니다.

#### URN

URN(Uniform Resource Name)은 리소스의 위치에 영향을 받지 않는 유일무이한 이름 역할을 합니다.
위치에 영향을 받지 않으므로, 리소스를 여기저기 옮기더라도 문제없이 동작합니다. 이름만 변하지 않고
유지된다면, 여러 종류의 네트워크 접속 프로토콜로 접근해도 무방합니다. 다만 URN은 아직 실험 중인
상태라고 합니다. 결국 리소스를 전달해주기 위해서는 이름(urn)을 듣고 해당 리소스가 있는 위치를 찾아야
하는데 이를 위한 인프라가 아직 구축되지 않아 URN이 널리 쓰이고 있지는 않습니다.

## 트랜잭션

DB에서의 트랜잭션은 Atomicity를 지키기 위해 존재하는 행동 단위입니다. HTTP에서는 클라이언트
에서 서버로 보내는 **요청**과 서버가 클라이언트에게 돌려주는 **응답**이 하나의 단위로 동작하여
트랜잭션이라고 이름을 붙인 것 같습니다. 이 요청과 응답이 잘 상호작용하도록 정형화된
HTTP 메시지를 이용합니다.

### 메소드

HTTP 메소드 | 설명
---|---
GET | 서버에서 클라이언트로 지정한 리소스를 보내라
PUT | 클라이언트에서 서버로 보낸 데이터를 지정한 이름의 리소스로 저장하라
DELETE | 지정한 리소스를 서버에서 삭제하라
POST | 클라이언트 데이터를 서버 게이트웨이 애플리케이션으로 보내라
HEAD | 지정한 리소스에 대한 응답에서, HTTP 헤어 부분만 보내라

좀 더 자세한 내용은 3장에서 설명하겠습니다.

### 상태코드

아마 404 에러가 뭔지는 몰라도 많이 보셨을 겁니다. 404는 리소스를 찾을 수 없다는 것을 나타내는
상태코드입니다. 모든 HTTP 응답에는 요청이 성공했는지 추가 조치가 필요한지 알려주는 상태코드와 함께
반환됩니다. 404 외에 성공했다는 의미의 200, 서버 내부 에러를 나타내는 500등 여러가지가 있습니다.
좀 더 자세한 것은 3장에서 다시 설명하겠습니다.

## 메시지

HTTP 메시지는 기계어로 이루어지거나 이진 형식이 아닌 일반 텍스트이기 때문에, 그냥 봐도 꽤나 이해하기 쉽습니다.

![HTTP 요청 메시지](/static/images/blog/http-완벽-가이드/01/req.webp)

![HTTP 응답 메시지](/static/images/blog/http-완벽-가이드/01/res.webp)

위의 두 사진은 [about 페이지](/about)에 대한 요청 메시지와 응답 메시지입니다. <span style={{color: 'red'}}>빨간 상자는 시작줄</span>,
<span style={{color: 'gold'}}>노란 상자는 헤더</span>, <span style={{color: 'green'}}>초록 상자는 본문</span>
입니다.

* 시작줄: 메시지의 첫 줄로, 요청의 경우 무엇을 해야 하는지, 응답의 경우 무슨 일이 일어났는지를 나타냅니다.
* 헤더: 시작 줄 이후 0개 이상의 필드로 구성되며, 마지막 줄을 빈 줄로 헤더가 끝임을 알립니다.
* 본문: 어떤 종류의 데이터든(이미지, 비디오, 오디오, 소프트웨어 등) 들어갈 수 있는 메시지 본문이
필요에 따라 요청과 응답에 올 수 있습니다. 요청의 경우 서버로 데이터를 실어 보내며, 응답의 경우
클라이언트로 데이터를 반환합니다. 시작줄이나 헤더와 달리 이진데이터도 올 수 있습니다.

## TCP 커넥션

### TCP/IP

OSI 7계층을 들어보셨나요? HTTP는 애플리케이션 계층 프로토콜로 가장 상위 계층입니다. 그래서 네트워크
통신의 핵심적인 세부사항에 대해서 신경쓰지 않습니다. 그 대신 대중적이고 신뢰성 있는 인터넷 전송
프로토콜인 TCP/IP에게 네트워크 통신을 맡깁니다.

TCP는 다음과 같은 특징을 지니고 있습니다.

* 오류 없는 데이터 전송
* 순서에 맞는 전달 (데이터는 언제나 보낸 순서대로 도착합니다.)
* 조각나지 않는 데이터 스트림 (언제든 어떤 크기로든 보낼 수 있습니다.)

그래서 TCP 커넥션이 맺어지면, 클라이언트와 서버 컴퓨터 간 교환되는 메시지가 없어지거나, 손상되거나, 순서가 뒤바뀌어 수신되지 않고
HTTP 메시지를 올바르게 주고 받을 수 있게 됩니다.

### URL에서 문서를 보기까지

다음과 같은 순서로 웹브라우저는 URL을 통해 문서를 보여줍니다.

1. 웹브라우저는 서버의 URL에서 호스트 명을 추출합니다.
2. 웹브라우저는 서버의 호스트 명을 IP로 변환합니다.
3. 웹브라우저는 URL에서 포트번호(있다면)를 추출합니다.
4. 웹브라우저는 웹 서버와 TCP 커넥션을 맺습니다.
5. 웹브라우저는 서버에 HTTP 요청을 보냅니다.
6. 서버는 웹브라우저에 HTTP 응답을 돌려줍니다.
7. 커넥션이 닫히며느 웹브라우저는 문서를 보여줍니다.

이는 매우 대략적인 순서입니다. 호스트 명으로 IP로 얻기 위해 DNS 서버에 재귀적으로 요청하거나
캐시된 주소를 가져온다던지, TCP 커넥션을 맺기위해 3-way handshake를 한다던지 여러가지 절차가
있지만 여기에서는 모두 설명하지 않겠습니다. 이후에 좀 더 자세히 다루도록 하겠습니다.

## 프로토콜 버전

### HTTP/0.9

HTTP의 프로토타입 버전입니다. GET 메소드만 존재하며 MIME 타입이나, 헤더 등이 존재하지 않았습니다.
단순히 html 객체를 받아오기 위해 만들어진 버전으로, 금방 HTTP/1.0으로 대체되었습니다.

### HTTP/1.0

처음으로 널리 쓰이기 시작한 HTTP 버전입니다. 헤더, 추가 메소드, 멀티미디어 객체 처리를 추가했습니다.
HTTP/1.0으로 시각적으로 매력적인 웹페이지와 상호작용하는 폼을 실현했으며, 월드 와이드 웹(www)을 대세로
만들었습니다.

### HTTP/1.0+

www이 성공함에 따라 여러 요구를 만족시키기 위해 여러가지 기능들(keep-alive 커넥션, 가상 호스팅 지원,
프록시 연결 지원 등)을 공식적이지는 않지만 사실상 표준으로 HTTP에 추가되었습니다. 이 규격 외의 확장된
HTTP 버전을 HTTP/1.0+라고 부릅니다.

### HTTP/1.1
이 버전은 HTTP 설계의 구조적 결함 교정, 두드러진 성능 최적화, 잘못된 기능 제거에 집중한 버전입니다.
또, 더 복잡해진 웹 애플리케이션과 배포를 지원합니다. 이 버전은 현재 널리 쓰이는 HTTP 버전입니다.

### HTTP/2.0
HTTP/1.1 성능 문제를 개선하기 위해 구글의 SPDY 프로토콜을 기반으로 설계되었습니다. 대표적인 특징들로는
헤더의 압축, 클라이언트가 추가로 요청하지 않은 리소스를 추후에 서버가 주는 Server push,
HOL Blocking 문제 해결, Stream 우선순위 지정 등이 있습니다.

### HTTP/3.0

기존 HTTP는 TCP 기반으로 통신하는 것과 달리 HTTP/3.0은 UDP 기반의 QUIC 프로토콜로 통신합니다.
UDP 위에 새로운 전송계층을 추가함으로써 패킷 재전송, 혼잡 제어, 속도 제어 등 여러가지 기능을 제공한다고 합니다.
아직 공부가 충분하지 않아서, 더 공부한 이후에 다시 글을 작성하겠습니다.

## 웹의 구성요소

### 프록시

프록시는 클라이언트와 서버 사이에 위치한 HTTP 중개자로 주로 보안을 위해 사용됩니다.
클라이언트의 모든 HTTP 요청을 받아 서버에 전달하는데, 요청과 응답을 필터링할 수 있습니다.
예를 들어, 무언가 다운로드 받을 때 바이러스가 있는지 검출하거나 성인 콘텐츠를 차단하는 등의 역할을 할 수 있습니다.

### 캐시

웹캐시와 캐시 프록시는 사람들이 자주 찾는 것의 사본을 저장해두는, 특별한 종류의 HTTP 프록시 서버입니다.
HTTP는 캐시를 효율적으로 동작하게 하고 캐시된 콘텐츠를 최신 버전으로 유지하면서 동시에 프라이버시도 보호하기 위한 많은 기능을 정의하고 있습니다.

### 게이트웨이

게이트웨이는 다른 서버들의 중개자로 동작하는 특별한 서버입니다.주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용되는데,
스스로가 리소스를 갖고 있는 진짜 서버인 것처럼 요청을 다룹니다. 그래서 요청을 보낸 클라이언트는
자신이 게이트웨이와 통신하고 있다는 사실을 알아채지 못합니다.

### 터널

터널은 두 커넥션 사이에서 raw한 데이터를 열어보지 않고 그대로 전달해주는 HTTP 애플리케이션입니다.
HTTP 터널은 주로 HTTP 데이터가 아닌 데이터를 하나 이상의 HTTP 연결을 이용하여 전송해주기 위해 사용됩니다.
예를 들어, 암호화된 SSL 트래픽을 HTTP 커넥션으로 전송하여 웹 트래픽만 허용하는 방화벽을 통과시키는 등의 방법으로 사용할 수 있습니다.

### 에이전트

에이전트는 사용자를 위해 HTTP 요청을 만들어주는 클라이언트 프로그램입니다. 대표적으로 웹브라우저가 있습니다.
우리가 사이트에 접속할 때 GET 요청을 명시적으로 보내지 않고, URL 입력창에 도메인 주소만 넣어주어도 볼 수 있는 이유는
웹브라우저가 입력받은 도메인 주소로 GET 요청을 만들어서 보내주기 때문입니다.
