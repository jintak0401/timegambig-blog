---
title: HTTP 메시지(상태코드와 헤더) - HTTP 완벽 가이드 3장(2)
date: '2022-12-29'
lastmod: '2022-12-30'
tags: ['네트워크']
draft: false
series: HTTP 완벽 가이드
summary: HTTP 완벽 가이드 3장, HTTP 상태코드와 헤더에 대해 정리하였습니다.
images: [https://i.imgur.com/FWceD2q.png]
layout: PostLayout
---

## HTTP 상태 코드

### 2xx Success

<h4 style={{color: '#6366f1'}}>200 OK</h4>
요청은 정상이며 엔터티 본문은 요청된 리소스를 포함하고 있습니다.

<h4 style={{color: '#6366f1'}}>201 Created</h4>
요청이 성공적으로 처리되어 새로운 리소스가 생성되었습니다. 이 상태코드는 POST, PUT 메소드같이 새로운 리소스 생성을 요청하는 메소드의 응답으로 사용됩니다.

<h4 style={{color: '#6366f1'}}>202 Accepted</h4>
요청은 접수되었으나 아직 처리되지 않았습니다. 서버가 요청의 처리를 완료할 것인지에 대한 보장을 해주지는 않습니다.

<h4 style={{color: '#6366f1'}}>203 Non-Authoritative Information</h4>
요청이 성공했지만 응답이 프록시에 의해 원본 서버의 200(OK) 응답에서 수정되었습니다.^[책의 설명이 잘 이해가 가지 않아 [RFC 7231](https://www.rfc-editor.org/rfc/rfc7231#section-6.3.4)을 참고했습니다.]

<h4 style={{color: '#6366f1'}}>204 No Content</h4>
응답 메시지에 시작줄과 헤더만 포함하고 본문은 포함하지 않습니다. 이 상태코드는 클라이언트가 서버에게 요청을 보내고 응답을 받기만 하면 되는 경우에 사용됩니다.

<h4 style={{color: '#6366f1'}}>205 Reset Content</h4>
브라우저를 위해 사용되는 상태코드로, 현재 페이지의 HTML Form에 채워진 값들을 모두 비우라고 말합니다.

<h4 style={{color: '#6366f1'}}>206 Partial Content</h4>
부분 혹은 범위 요청에 성공했습니다. 이 상태코드는 Range 헤더를 사용한 요청에 대한 응답으로 사용됩니다.
<br/>
### 3xx Redirection

![https://timegambit.com으로 접속했을 때](https://i.imgur.com/XfMpLji.png)

[vercel](https://vercel.com)로 호스팅하고 있는 이 블로그는 timegambit.com 으로 접속하면 자동으로 http<span>s://w</span>ww.timegambit.com 으로 리다이렉트 됩니다. 이처럼 리다이렉션과 관련된 상태코드는 3xx입니다.^[Google, Instagram, Facebook은 example.com으로 접속하면 ww<span>w.e</span>xample.com으로 리다이렉트됩니다. 반대로 GitHub, Discord는 ww<span>w.e</span>xample.com으로 접속하면 example.com으로 리다이렉트됩니다.]

<h4 style={{color: '#6366f1'}}>300 Multiple Choices</h4>
클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청한 경우, 리소스의 목록과 함께 반환합니다. 사용자는 목록에서 원하는 하나를 선택해야 합니다.

<h4 style={{color: '#6366f1'}}>301 Moved Permanently</h4>
요청한 URL이 옮겨졌습니다. location 헤더에 현재 리소스가 존재하고 있는 URL을 포함됩니다.

<h4 style={{color: '#6366f1'}}>302 Found</h4>
301 Moved Permanently와 비슷합니다. 차이점은 location 헤더로 주어진 URL은 리소스를 가리키는 임시 URL입니다.

<h4 style={{color: '#6366f1'}}>303 See Other</h4>
클라이언트에게 리소스를 다른 URL에서 가져와야 한다고 알려줍니다. 새 URL은 location 헤더에 포함됩니다.

<h4 style={{color: '#6366f1'}}>304 Not Modified</h4>
클라이언트가 요청한 리소스가 변경되지 않았음을 알려줍니다. 이 상태코드는 클라이언트가 캐시된 리소스를 사용할 수 있음을 알려줍니다.
응답의 본문은 없습니다.

<h4 style={{color: '#6366f1'}}>305 Use Proxy</h4>
리소스가 프록시를 통해서 접근되어야 합니다. 다만 보안상의 이유로 거의 사용되지 않습니다.

<h4 style={{color: '#6366f1'}}>307 Temporary Redirect</h4>
302 Found와 비슷하게 리소스를 가져올 수 있는 임시 URL을 location 헤더로 알려줍니다. 차이점은 HTTP 메소드를 변경하지 말아야 한다는 점입니다. 예를 들어 첫 요청에 POST 메소드를 사용했다면, 307 상태코드를 받은 후에도 POST 메소드를 사용해야 합니다.

<h4 style={{color: '#6366f1'}}>308 Permanent Redirect</h4>
301 Moved Permanently와 비슷하게 리소스를 가져올 수 있는 옮겨진 URL을 location 헤더로 알려줍니다. 차이점은 HTTP 메소드를 변경하지 말아야 한다는 점입니다. 예를 들어 첫 요청에 POST 메소드를 사용했다면, 308 상태코드를 받은 후에도 POST 메소드를 사용해야 합니다.
<br/>
### 4xx Client Error

![Time Gambit 블로그 404 페이지](https://i.imgur.com/3jRtSLi.png)

개발자가 아닌 분들도 404 Not Found는 알고있지 않을까 싶을 정도로 많이 볼 수 있는 에러입니다. 많은 클라이언트 에러는 우리들을 귀찮게 하지 않고 브라우저에 의해 처리되지만, 404를 비롯한 몇몇은 저희에게 전달됩니다.

<h4 style={{color: '#6366f1'}}>400 Bad Request</h4>
클라이언트가 잘못된 요청을 보냈음을 의미합니다.

<h4 style={{color: '#6366f1'}}>401 Unauthorized</h4>
리소스를 얻기 전에 클라이언트에게 인증을 요구합니다. 사유구절은 **비인가**(Unauthorized)이지만 **인증이 되지 않았음**(Unauthenticated)을 의미합니다.^[**인가**란 사용자의 권한을 확인하는 것이며, **인증**이란 사용자가 누구인지 확인하는 것입니다. 예를들어 로그인은 누구인지 확인하기 위해 **인증**하는 절차이며, 해당 계정이 일반 계정인지 관리자 계정인지 확인하는 것은 **인가**입니다.]

<h4 style={{color: '#6366f1'}}>402 Payment Required</h4>
미래에 디지털 결제 시스템에 사용하기 위해 만들어졌지만, 현재 사용되고 있지는 않습니다.

<h4 style={{color: '#6366f1'}}>403 Forbidden</h4>
요청이 서버에 의해 거부되었습니다. 거부 이유를 본문에 포함시킬 수 있지만, 보통 서버가 거절의 이유를 숨기고 싶을 때 사용됩니다. 401 Unauthorized와의 차이점은 403 Forbidden에서는 클라이언트가 누구인지 알고 있다는 점입니다.

<h4 style={{color: '#6366f1'}}>404 Not Found</h4>
서버가 요청한 URL을 찾을 수 없습니다. 서버가 인가되지 않은 클라이언트에게 리소스를 숨기고 싶을 때 403 Forbidden 대신 사용하기도 합니다.

<h4 style={{color: '#6366f1'}}>405 Method Not Allowed</h4>
지원하지 않는 메소드로 요청을 받았음을 의미합니다. 서버는 클라이언트에게 사용 가능한 메소드를 알려주기 위해 Allow 헤더를 포함시킬 수 있습니다.

<h4 style={{color: '#6366f1'}}>406 Not Acceptable</h4>
클라이언트는 어떤 종류의 엔터티를 받아들이고자 하는지 명시할 수 있습니다. 이 상태코드는 주어진 URL에 대한 리소스 중 클라이언트가 받아들일 수 있는 것이 없음을 의미합니다. 예를 들어 클라이언트가 text/html을 받아들일 수 있지만, 서버가 text/plain만 제공할 때 사용됩니다.

<h4 style={{color: '#6366f1'}}>407 Proxy Authentication Required</h4>
클라이언트가 프록시를 통해 서버에 접근하려고 할 때, 프록시가 클라이언트에게 인증을 요구합니다. 401 Unauthorized와 비슷하지만, 407 Proxy Authentication Required는 프록시가 인증을 요구한다는 점이 다릅니다.

<h4 style={{color: '#6366f1'}}>408 Request Timeout</h4>
클라이언트의 요청을 완수하기에 시간이 너무 많이 걸리는 경우, 서버는 이 상태 코드로 응답하고 연결을 끊을 수 있습니다.

<h4 style={{color: '#6366f1'}}>409 Conflict</h4>
서버가 요청을 수행하는 중에 충돌이 발생했음을 의미합니다. 서버는 충돌의 이유를 본문에 포함시킬 수 있습니다.

<h4 style={{color: '#6366f1'}}>410 Gone</h4>
404 Not Found와 비슷하지만 리소스를 한때 갖고 있었다는 점이 다릅니다. 클라이언트에게 리소스가 제거되었음을 알려주기 위해 사용합니다.

<h4 style={{color: '#6366f1'}}>411 Length Required</h4>
서버가 Content-Length 헤더를 요구하는데, 클라이언트가 요청에 Content-Length 헤더를 포함시키지 않았을 때 사용됩니다.

<h4 style={{color: '#6366f1'}}>412 Precondition Failed</h4>
클라이언트가 조건부 요청을 했는데 그 중 하나가 실패했음을 알려줍니다. 조건부 요청은 클라이언트가 Expect 헤더를 포함했을 때 발생합니다.

<h4 style={{color: '#6366f1'}}>413 Request Entity Too Large</h4>
서버가 처리할 수 있는 혹은 처리하고자 하는 한계를 넘은 크기의 요청입니다.

<h4 style={{color: '#6366f1'}}>414 Request-URI Too Long</h4>
요청한 URL이 너무 깁니다.

<h4 style={{color: '#6366f1'}}>415 Unsupported Media Type</h4>
서버가 이해하거나 지원하지 못하는 내용 유형의 엔터티를 클라이언트가 보냈음을 의미합니다.

<h4 style={{color: '#6366f1'}}>416 Requested Range Not Satisfiable</h4>
클라이언트가 Range 헤더를 포함하여 리소스의 특정 범위를 요청했는데, 서버가 그 범위를 처리할 수 없음을 의미합니다.

<h4 style={{color: '#6366f1'}}>417 Expectation Failed</h4>
클라이언트가 Expect 헤더를 포함한 요청을 보냈지만, 서버가 그 조건을 만족시키지 못함을 의미합니다. 서버가 조건을 만족시킬 수 없을 명확한 증거를 프록시가 가지고 있다면 이 상태코드를 전송할 수 있습니다.
<br/>
### 5xx Server Error

클라이언트가 올바른 요청을 보냈음에도 서버 자체에서 에러가 발생하는 경우도 때때로 있습니다. 이런 경우에는 5xx 상태코드를 사용합니다.

<h4 style={{color: '#6366f1'}}>500 Internal Server Error</h4>
서버에 에러가 발생했음을 의미합니다. 서버가 에러를 자세히 설명할 수 없다면 이 코드를 사용합니다.

<h4 style={{color: '#6366f1'}}>501 Not Implemented</h4>
서버가 알 수 없는 메소드를 사용한 경우처럼, 클라이언트가 서버의 능력을 넘은 요청을 했을 때 사용합니다.^[405 Method Not Allowed와의 차이점은 405의 경우 서버가 해당 메소드를 알고 있지만 지원하지 않는다는 것이고, 501 Not Implemented의 경우 서버가 해당 메소드를 모르고 있음을 의미합니다. 예를 들어 'XYZ' 메소드를 클라이언트가 요청해왔을 때, 서버가 'XYZ' 메소드를 알고 있지만 지원하지 않는다면 405 Method Not Allowed를, 서버가 'XYZ' 메소드를 모르고 있다면 501 Not Implemented를 사용합니다.]

<h4 style={{color: '#6366f1'}}>502 Bad Gateway</h4>
서버가 게이트웨이나 프록시 역할을 하고 있고, 그 서버가 다른 서버로부터 유효하지 않은 응답을 받았을 때 사용합니다.

<h4 style={{color: '#6366f1'}}>503 Service Unavailable</h4>
현재는 서버가 요청을 처리해줄 수 없지만 나중에는 가능함을 의미합니다. 만약 서버가 언제 그 리소스를 사용할 수 있게 될지 알고 있다면, Retry-After 헤더를 응답에 포함할 수 있습니다.

<h4 style={{color: '#6366f1'}}>504 Gateway Timeout</h4>
서버가 게이트웨이나 프록시 역할을 하고 있고, 그 서버가 다른 서버에서 응답을 받는데 시간이 너무 오래 걸렸을 때 사용합니다.

<h4 style={{color: '#6366f1'}}>505 HTTP Version Not Supported</h4>
서버가 요청에 사용된 HTTP 프로토콜의 버전을 지원하지 않을 때 사용합니다.
<br/>
## 헤더
HTTP 헤더는 클라이언트와 서버가 요청과 응답을 주고받는 과정에서 추가적인 정보를 주고받을 수 있도록 해줍니다. 헤더는 크게 일반 헤더, 요청 헤더, 응답 헤더, 엔터티 헤더, 확장 헤더, 총 다섯 가지로 분류됩니다.

### 일반 헤더(General Headers)
일반 헤더는 클라이언트와 서버 양쪽 모두가 사용할 수 있습니다. 일반 헤더는 클라이언트, 서버, 어딘가에 메시지를 보내는 다른 애플리케이션들을 위해 다양한 목적으로 사용됩니다.
#### 일반 정보 헤더
|헤더|설명|
|---|---|
|Connection|클라이언트와 서버가 요청/응답 연결에 대한 옵션을 정할 수 있게 해줍니다.|
|Date|메시지가 생성된 날짜와 시간을 나타냅니다.|
|MIME-Version|발송자가 사용한 MIME 버전을 알려줍니다.|
|Trailer Chunked transfer|인코딩된 메시지의 끝 부분에 위치한 헤더들의 목록을 나열합니다.|
|Transfer-Encoding|수신자에게 안전한 전송을 위해 메시지에 적용된 인코딩 방법을 알려줍니다.|
|Upgrade|발송자가 업그레이드하길 원하는 새 버전이나 프로토콜을 알려줍니다.|
|Via|메시지가 어떤 중개자(프록시, 게이트웨이)들을 거쳐왔는지 보여줍니다.|
<br/>
#### 일반 캐시 헤더
|헤더|설명|
|:---|:---|
|Cache-Control|캐시를 어떻게 사용할지에 대한 지시를 제공합니다.([참고](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/Cache-Control))|
|Pragma|캐시를 어떻게 사용할지에 대한 지시를 제공하는 또 다른 방법입니다. 캐시에 국한되는 헤더는 아닙니다. ^[Pragma는 엄밀히 말하면 요청 헤더이며, 응답에 사용하기 위해 정의되지 않습니다. 응답 헤더로 사용하는 흔한 오용 때문에 클라이언트와 프록시는 Pragma를 응답 헤더로 새거하지만, 엄밀한 의미는 잘 정의되어 있지 않습니다. Pragma는 Cache-Control로 인해 deprecated될 예정입니다.]|
<br/>
### 요청 헤더(Request Headers)
요청 헤더는 이름 그대로 요청 메시지를 위한 헤더입니다. 클라이언트가 서버에게 받고자 하는 데이터의 타입이 무엇인지와 같은 부가 정보를 제공합니다.

#### 요청 정보 헤더
|헤더|설명|
|---|---|
|Client-IP|클라이언트의 IP 주소를 나타냅니다.|
|From|클라이언트의 이메일 주소를 나타냅니다.|
|Host|요청의 대상이 되는 서버의 호스트 명과 포트를 나타냅니다.|
|Referer|클라이언트가 보낸 요청 URI가 들어있던 페이지의 URL을 나타냅니다.|
|User-Agent|클라이언트의 소프트웨어 정보를 나타냅니다.|
<br/>
#### Accept 관련 헤더
클라이언트는 Accept 관련 헤더들을 이용해 서버에게 자신이 받고자 하는 데이터의 타입을 알려줍니다. 즉 클라이언트가 무엇을 원하고 무엇을 할 수 있는지, 무엇보다 원치 않는 것은 무엇인지 알려줄 수 있습니다. 서버는 그 후 이 정보를 활용해서 무엇을 보낼 것인가에 대해 더 똑똑한 결정을 내릴 수 있습니다. 클라이언트는 원하는 것을 얻을 수 있고, 서버는 잘못된 데이터를 전송하는 데 시간과 대역폭을 낭비하지 않을 수 있으므로 양쪽 모두에게 이득이 됩니다.
|헤더|설명|
|---|---|
|Accept|클라이언트가 받고자 하는 데이터의 타입을 나타냅니다.|
|Accept-Charset|클라이언트가 받고자 하는 문자 인코딩을 나타냅니다.|
|Accept-Encoding|클라이언트가 받고자 하는 데이터의 압축 방식을 나타냅니다.|
|Accept-Language|클라이언트가 받고자 하는 데이터의 언어를 나타냅니다.|
<br/>
#### 조건부 요청 헤더
때때로 클라이언트는 요청에 제약을 넣기도 합니다. 예를 들어 클라이언트가 리소스를 요청할 때, 자신이 갖고 있는 리소스의 사본과 서버의 원본과 다를 경우에만 전송해 달라고 요청하고 싶을 수 있습니다. 조건부 요청 헤더를 사용하면, 클라이언트는 서버에게 응답하기 전에 먼저 조건이 참인지 확인하게 하는 제약을 포함시킬 수 있습니다.
|헤더|설명|
|---|---|
|If-Match|리소스의 ETag와 주어진 ETag가 일치하는 경우에만 리소스를 전송해 달라고 요청합니다.|
|If-None-Match|리소스의 ETag와 주어진 ETag가 일치하지 않는 경우에만 리소스를 전송해 달라고 요청합니다.|
|If-Modified-Since|주어진 날짜 이후에 리소스가 변경되었을 경우 전송해 달라고 요청합니다.|
|If-Unmodified-Since|주어진 날짜 이후에 리소스가 변경되지 않았을 경우 전송해 달라고 요청합니다.|
|If-Range|리소스의 특정 범위에 대해 요청할 수 있게 해줍니다.|
|Range|서버가 범위 요청을 지원한다면, 리소스의 특정 범위에 대해 요청합니다.|
<br/>
#### 요청 보안 헤더
HTTP는 자체적으로 요청을 위한 간단한 인증요구/응답 체계를 가지고 있습니다. 이를 통해 클라이언트가 리소스에 접근하기 전에 자신을 인증하게 함으로써 트랜잭션을 약간 더 안전하게 만들 수 있습니다.
|헤더|설명|
|---|---|
|Authorization|클라이언트가 서버에게 제공하는 인증 자체에 대한 정보를 담고 있습니다.|
|Cookie|클라이언트가 서버에게 토큰을 전달할 때 사용합니다.|
|Cookie2|요청자가 지원하는 쿠키의 버전을 알려줄 때 사용합니다.|
<br/>
#### 프록시 요청 헤더
|헤더|설명|
|---|---|
|Max-Forwards|요청이 서버로 향하는 과정에서 다른 프록시나 게이트웨이로 전달될 수 있는 최대 횟수입니다. TRACE 메소드와 함께 사용됩니다.|
|Proxy-Authorization|Authorization 헤더와 같지만 프록시에서 인증할 때 쓰입니다.|
|Proxy-Connection|Connection 헤더와 같지만 프록시에서 연결을 맺을 때 쓰입니다.|
<br/>
### 응답 헤더(Response Headers)
응답 메시지는 클라이언트에게 정보를 제공하기 위한 자신만의 헤더를 갖고 있습니다. 누가 응답을 보내고 있는지, 응답자의 능력은 어떻게 되는지, 더 나아가 응답에 대한 특별한 설명도 제공할 수 있습니다. 이 헤더들은 클라이언트가 응답을 잘 다루고 나중에 더 나은 요청을 할 수 있도록 도와줍니다.
#### 응답 정보 헤더
|헤더|설명|
|---|---|
|Age|응답이 프록시 캐시 내에 몇 초동안 있었는지를 나타냅니다.(프록시 캐시를 통해 왔음을 암시합니다.)|
|Retry-After|클라이언트가 요청을 재시도할 수 있는 시간을 나타냅니다.|
|Server|응답을 보내는 서버의 소프트웨어 정보를 나타냅니다.|
|Warning|사유 구절에 있는 것보다 더 자세한 경고 메시지입니다.|
<br/>
#### 협상 헤더
하나의 리소스를 데스크톱과 모바일에서 다르게 보여줄 필요가 있을 수 있습니다. URL은 동일하지만 다른 리소스를 줘야하는 경우, HTTP/1.1은 서버와 클라이언트가 어떤 리소스를 선택할 것인지 협상을 할 수 있도록 지원합니다.
|헤더|설명|
|---|---|
|Accept-Ranges|서버가 Range 요청을 지원하는지를 나타냅니다.|
|Vary|서버가 확인해 보아야 하고 응답에 영향을 줄 수 있는 헤더들의 목록입니다.^[예를 들어 `Vary: User-Agent`인 경우 데스크톱과 모바일 등 에이전트에 따라 다른 리소스를 주게 됩니다.]|
<br/>
#### 응답 보안 헤더
|헤더|설명|
|---|---|
|Proxy-Authenticate|프록시가 클라이언트를 인증할 때 쓰입니다.|
|Set-Cookie|서버가 클라이언트에게 쿠키를 설정할 때 쓰입니다.|
|WWW-Authenticate|서버에서 클라이언트로 보내는 인증요구 목록입니다.|
<br/>
### 엔터티 헤더(Entity Headers)
엔터티 헤더는 엔터티 본문에 대한 헤더를 말합니다. 요청과 응답 양쪽 모두 본문을 포함할 수 있기 때문에, 엔터티 헤더는 두 타입의 메시지에 모두 나타날 수 있습니다. 엔터티 헤더는 본문과 내용에 대한 개체의 타입부터 시작해서 리소스에 대해 요청할 수 있는 유효한 메소드들까지, 광범위한 정보를 제공합니다. 일반적으로 엔터티 헤더는 메시지의 수신자에게 자신이 다루고 있는 것이 무엇인지 말해줍니다.
<br/>
#### 엔터티 정보 헤더
|헤더|설명|
|---|---|
|Allow|리소스에 대해 수행될 수 있는 요청 메소드들 목록입니다.|
|Location|클라이언트에게 리소스가 실제로 어디에 위치하고 있는지 말해줍니다. 수신자에게 리소스에 대한 위치(URL)를 알려줄 때 사용합니다.|
<br/>
#### 콘텐츠 헤더
콘텐츠 헤더는 본문의 콘텐츠에 대한 구체적인 정보를 제공합니다. 콘텐츠의 종류, 크기, 기타 콘텐츠를 처리할 때 유용하게 활용될 수 있는 것들입니다.
|헤더|설명|
|---|---|
|Content-Encoding|본문의 콘텐츠가 어떤 인코딩을 사용했는지 말해줍니다.|
|Content-Language|본문의 콘텐츠가 어떤 언어로 작성되었는지 말해줍니다.|
|Content-Length|본문의 크기를 바이트 단위로 말해줍니다.|
|Content-Location|본문이 실제로 어디에 위치하고 있는지 말해줍니다.|
|Content-MD5|본문의 콘텐츠에 대한 MD5 체크섬을 말해줍니다.|
|Content-Range|전체 리소스에서 이 엔터티가 해당하는 범위를 바이트 단위로 말해줍니다.|
|Content-Type|본문의 콘텐츠가 어떤 타입인지 말해줍니다.|
<br/>
#### 엔터티 캐싱 헤더
리소스에 대해 캐시된 사본이 아직 유효한지, 캐시된 리소스가 더 이상 유효하지 않게 되는 시점 등 캐싱에 관련된 정보를 제공합니다.
|헤더|설명|
|---|---|
|ETag|리소스에 대한 식별값으로 리소스간 식별 및 리소스 수정 여부 등을 알 수 있게 해줍니다.|
|Expires|엔터티가 더 이상 유효하지 않아 다시 받아와야 하는 일시입니다.|
|Last-Modified|가장 최근 엔터티가 변경된 일시입니다.|

## 마치며
이번 포스트에서 HTTP 메시지의 상태코드들과 헤더들에 대해 알아보았습니다. 다음 포스트에서는 HTTP는 어떻게 커넥션을 이루는지에 대해 알아보겠습니다.

## Reference
1. [RFC 7231](https://www.rfc-editor.org/rfc/rfc7231)
2. [difference between 405 and 501 response](https://sip-implementors.cs.columbia.narkive.com/GcvjgCXr/difference-between-405-and-501-response)
