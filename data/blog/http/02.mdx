---
title: URI(URL & URN) - HTTP 완벽 가이드 2장
date: '2022-11-29'
lastmod: '2022-11-29'
tags: ['네트워크']
draft: false
series: HTTP 완벽 가이드
summary: HTTP 완벽 가이드 2장의 내용인 URI에 대한 개념을 정리한 글입니다.
images: [https://i.imgur.com/FWceD2q.png]
layout: PostLayout
---

## URI가 뭐지?

URI란 Uniform Resource Identifier의 약자입니다. 말 그대로 인터넷의 리소스들을 식별하도록 해주는 것이 URI입니다.
그리고 URI는 URL과 URN으로 구성되어 있습니다. 이 중 URL은 인터넷의 리소스를 가리키는 표준 이름입니다.

### URL과 URN의 차이점

제 이름은 꽤 독특합니다. 아마 제가 사는 아파트에서 제 이름과 같은 사람은 없을 겁니다. 만약 누군가가 저를 찾는다면
2가지 방법으로 찾을 수 있을 것입니다.

> 1. OOO동 XXX호에 사는 사람으로 찾는 방법 (**주소로 찾기**)
> 2. 제 본명으로 찾는 방법 (**이름으로 찾기**)

저를 리소스로 가정하면 1번 방법은 URL 방식으로, 2번 방법은 URN 방법으로 찾는 것입니다.
URL이란 Uniform Resource Locator, URN이란 Uniform Resource Name입니다. 즉 URL은 위치로, URN은 이름으로 찾습니다.

> 제가 OOO동 XXX호에서 □□□동 △△△호로 이사를 갔습니다.

제가 이사를 가면 어떻게 될까요? 그러면 OOO동 XXX호만 알고 있던 사람은 저를 더 이상 찾을 수 없을 것입니다.
반면, 제 본명을 알고 있는 사람은 제가 이사를 가더라도 찾을 수 있을 것입니다. 즉 URL 방식의 경우 리소스의 경로가 변경되면 알고 있던
경로로는 더 이상 찾을 수 없으며, URN 방식은 경로가 변경되더라도 이름만으로 리소스를 찾을 수 있습니다. 이렇게 이야기를 들으면
URN 방식이 현재 저희가 널리 쓰고 있는 URL 방식보다 더 좋아보이네요. 왜 URL 대신 URN을 쓰지 않고 URL을 주로 사용할까요?

### URN을 널리 사용하지 않는 이유

[이 사이트](https://datatracker.ietf.org/doc/rfc8141/)를 보면 URN은 2010년 3월부터 명세가 출시하기 시작하여,
2017년에는 RFC에 정식으로 출판되었네요.^[RFC란 IETF에서 제공 및 관리하는 문서로, 인터넷 기술에 적용할 수 있는 연구와 기법 등을 기술한 문서입니다.]
꽤나 오래되었습니다. 이 정도면 URL 대신 URN을 표준으로 써도 될 정도로 시간이 많이 지난 것 같은데 무엇이 문제이길래 여전히 URL이 표준으로
사용될까요?

결국 리소스를 주기 위해서는 해당 리소스가 어디있는지를 알아야만 합니다. 서버도 리소스의 이름을 듣고, 특정한 위치에서 리소스를 **찾아**
우리에게 전해줄 수 있지 않겠어요? 수많은 리소스들이 있고, 리소스들이 시시각각 위치가 변하더라도 요청할 때마다 척척 찾아서 우리에게
리소스를 주려면 서버는 이를 위한 인프라를 충분히 갖추어야 합니다. 하지만 그런 인프라가 아직은 없습니다.

또, URL을 이용해 많은 HTTP 애플리케이션이 만들어졌습니다. 그리고 우리도 그 URL 방식에 많이 익숙해져 있는 상태죠. 만약 URN으로 표준을
옮기려면 서비스를 제공해주는 업체들과의 합의도 필요하며, 우리 또한 URN에 익숙해져야합니다. 하지만 합의를 이룰만큼 URL의 문제가
심각하냐고 묻는다면 그 정도는 아닙니다. 그렇기 때문에 URL을 여전히 표준으로써 사용하고 있습니다.

## URL

```
<스킴>://<사용자 이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프래그먼트>
```

이게 뭐냐고요? 이 형태가 기본적인 URL 문법입니다. 단순히 알고있던 `https://timegambit.com/something`이나 길어봐야 `https://timegambit.com/something?id=123&key=value` 같은
형태와는 다르죠? 특히 `사용자 이름`과 `비밀번호`는 처음 보시는 분도 계실겁니다. 보신 적이 있다면 아마 FTP 프로토콜을 사용해 보신 적이 있거나
MySQL같은 데이터베이스를 Workbench나 DataGrip에 연결해보신 분이실겁니다. 각 컴포넌트가 어떤 역할을 하는지 밑에서 더 자세히 설명하도록 하겠습니다.
밑의 표는 간단히 정리한 컴포넌트 설명입니다.

|컴포넌트|설명|기본값|
|---|---|---|
|스킴|리소스를 가져오기 위한 프로토콜입니다.|없음|
|사용자 이름|몇몇 스킴은 리소스 접근을 위해 사용자 이름이 필요합니다.|anonymous|
|비밀번호|사용자의 비밀번호입니다.|브라우저에 따라 다름|
|호스트|리소스를 호스팅하는 서버 호스트 명이나 IP 주소입니다.|없음|
|포트|서버가 열어놓은 포트번호로 기본 포트를 열어놓은 경우 생략합니다.|스킴에 따라 다름|
|경로|서버 내 리소스의 위치를 나타내며, 이전 컴포넌트와 '/'으로 구분합니다.|없음|
|파라미터|특정 스킴들에서 입력 파라미터를 기술하는 용도로 사용됩니다. 이름/값을 쌍으로 가지며, 다른 파라미터나 경로의 일부와 세미콜론\(;)으로 구분하며 여러 개를 가질 수 있습니다.|없음|
|질의\(쿼리)|스킴에서 애플리케이션\(DB, 게시판, 검색엔진 등)에 파라미터를 전달하는데 쓰이며, URL 끝에 '?'으로 구분합니다. 공통적인 포맷은 없지만 대부분 '&'으로 나뉜 '이름=값' 쌍 형식의 포맷으로 작성합니다.|없음|
|프래그먼트|서버로 전달되지 않는, 클라이언트에서만 사용되는 리소스의 조각이나 일부분을 가리키는 컴포넌트입니다. URL 끝에서 '#'으로 구분합니다.|없음|

### 스킴: 사용할 프로토콜

스킴은 주어진 리소스에 어떻게 접근할지 알려주는 중요한 정보입니다.
브라우저를 이용해 웹사이트에 접속할 때 주로 `https`로 시작하는 사이트에 접속합니다. 그 사이트들의 스킴은 https로,
브라우저는 https 프로토콜을 이용해 해당 주소의 리소스를 가져와 화면에 그려줍니다.

참고로 스킴은 대소문자를 가리지 않습니다. 따라서 `https://~`으로 사이트에 접속하나 `HTTPS://~`으로 접속하나 같은 결과를 얻을 수 있습니다.

<Callout type="info">
  **Q. 그러면 https 외에 다른 스킴들로는 무엇이 있나요?**

  매우 다양합니다. https 이전에 사용하던 `http`도 있고, 파일전송 프로토콜인 `ftp`도 있으며,
  원격 MySQL 데이터베이스에 접속할 수 있는 `jdbc:mysql`도 있습니다.
  심지어 로컬 리소스에 접근할 수 있는 `file` 스킴도 있습니다. 이 외에도
  `mailto`, `rtsp`, `rtspu`, `news`, `telnet` 등 많습니다.
</Callout>

### 호스트와 포트

인터넷에 존재하는 리소스를 찾으려면, 리소스를 호스팅하고 있는 장비(**호스트**)와 그 장비 내 리소스에
접근할 수 있도록 서버가 열어놓은 통로(**포트**)를 알아야 합니다.

1. https://www.google.com
2. https://142.250.206.206:443

위 2개의 주소는 우리들의 신, 구글에 접속할 수 있는 URL입니다.
1번의 `www.google.com`과 2번의 `142.250.206.206`은 호스트 컴포넌트입니다. 차이점은 1번의 경우
호스트 명으로, 2번의 경우 IP 주소로 호스트를 가리키고 있다는 점입니다.

또 다른 차이점으로는 1번에는 포트번호가 없지만, 2번에는 포트번호인 443가 있다는 점입니다.
포트번호는 명시해줘도 됩니다만, 포트번호와 스킴의 기본 포트번호가 일치하는 경우 생략할 수도 있습니다.
https의 경우 443번, http의 경우 80번 포트가 기본 포트입니다. 위 2번의 경우
https의 기본포트번호인 443을 사용하므로 https://142.250.206.206 으로 접속해도
동일한 결과를 얻을 수 있습니다.

### 사용자 이름과 비밀번호

서버가 자신이 가지고 있는 데이터에 접근을 허용하기 전에 사용자 이름과 비밀번호를 요구할 때가 있습니다.
대표적인 예가 FTP 서버와 원격 데이터베이스 접속이 좋은 예입니다.

* ftp://ftp.prep.ai.mit.edu/pub/gnu
* ftp://anonymous@ftp.prep.ai.mit.edu/pub/gnu
* ftp://anonymous:my_passwd<span>@</span>ftp.prep.ai.mit.edu/pub/gnu
* ht<span>tp://goe:goespasswd@w</span>ww.joes-hardware.com/saleds_info.txt
* jdbc:mysql://username:password@sqlserver:3306

URL에 `@` 문자가 존재한다면 URL로부터 사용자 이름과 비밀번호를 분리합니다.
사용자 이름과 비밀번호는 `:` 문자로 분리하며, 사용자 이름이 없거나 비밀번호가 없다면 기본값이 들어갑니다.
사용자이름의 기본값은 `anonymous`이며, 비밀번호는 브라우저마다 다릅니다.
크롬의 경우에는 `chrome@example.com`을 넣는다고 합니다.

### 경로

URL의 경로 컴포넌트는 리소스가 서버의 어디에 있는지 알려줍니다. https://timegambit.com/blog/http-02 를
보면, `/blog/http-02`가 경로 컴포넌트입니다. HTTP URL에서 경로 컴포넌트는 '/' 문자를
기준으로 경로조각이 나뉘는데, 이 예에서는 `/blog`와 `/http-02`로 나뉘겠네요.

### 파라미터

URL을 사용하는 애플리케이션이 리소스에 접근하려면 프로토콜 파라미터가 필요합니다.
프로토콜 파라미터가 없으면, 다른 한편에 있는 서버는 그 요청을 잘못 처리하거나
처리를 하지 않을 것입니다.

예를들어 바이너리와 텍스트, 총 2개의 포맷을 지원하는 FTP를 생각해봅시다.
텍스트 형식으로 전송된다면 이미지가 엉망이 되겠죠? 따라서 사용자는 바이너리 이미지가
텍스트 형식으로 전송되는 것을 원하지 않을 것입니다.

**URL의 파라미터 컴포넌트는 애플리케이션이 서버에 정확한 요청을 하기 위해 필요한 입력 파라미터를 받는데 사용합니다.**

1. ftp://prep.ai.mit.edu/pub/gnu;type=d
2. ht<span>tp://joes-hardware.co</span>m/hammers;sale=false/index.html;graphics=true

파라미터 컴포넌트는 이름/값 쌍의 리스트로 URL 나머지 부분들로부터 ';' 문자로 구분하여 URL에 기술합니다.
1번 예의 경우 이름이 `type`이고 값이 `d`인 단 한 개의 파라미터를 전달합니다.
위에서 경로 컴포넌트는 경로조각으로 나눌 수 있다고 했습니다. 2번 예의 경우 `hammers`와 `index.html` 2개의 경로조각으로 나뉩니다.
hammers의 경우 값이 false인 sale 파라미터를 가지며, index.html 경로조각은 값이 true인 graphics 파라미터를 가집니다.

### 질의(쿼리) 문자열

검색 엔진이나 게시판 사이트의 URL에서 '?' 뒤에 '이름=값' 쌍 형태의 문자열이 '&'으로 연결된 것을 보신적 있나요?
이 부분이 질의(쿼리) 문자열입니다. 데이터베이스 같은 서비스들은 요청받을 리소스 형식의 범위를 좁히기 위해서 질문이나 질의를 받을 수 있는데,
질의 컴포넌트를 사용합니다.

1. https://www.youtube.com/results?search_query=체스
2. https://search.naver.com/search.naver?where=nexearch&sm=top_hty&fbm=1&ie=utf8&query=네이버

1번의 경우 `search_query=체스`라는 1개의 질의만 있습니다. 2번의 경우
`where=nexearch`, `sm=top_hty`, `fbm=1`, `ie=utf8`, `query=네이버` 총 5개의 질의가 있네요.
이렇게 여러개인 경우 '&'로 연결해줍니다.

다만 질의 컴포넌트가 '&'로 나뉜 '이름=값'쌍 형식으로만 이루어져야 하는 것은 아닙니다.
몇몇 특정 문자들을 제외하고는 질의 컴포넌트 포맷에 제약은 없습니다. 단지 편의상 많은 게이트웨이가
이러한 포맷을 원하기 때문에 이러한 형태로 사용하고 있을 뿐입니다.

### 프래그먼트

PC 화면으로 제 블로그를 보고 계신 분이라면 오른쪽에 TOC가 보이실 겁니다. TOC의 제목을 클릭하면
해당 글로 이동합니다. 이동하셨다면 URL 창을 봐주세요. '#'와 그 뒤에 클릭하신 제목이 보이시나요?
이 부분이 프래그먼트 컴포넌트입니다.

리소스의 특정 부분을 가리킬 수 있도록, URL은 리소스 내의 조각을 가리킬 수 있는 컴포넌트를 제공합니다.
일반적으로 HTTP 서버는 객체 일부가 아닌 전체만을 다룹니다. 리소스의 특정 부분을 가리키는 프래그먼트는
전체를 다루는 서버로 전달되지 않습니다. 클라이언트(브라우저)가 프래그먼트로 여러분이 보고자 하는
리소스의 일부를 보여줄 뿐이죠.

## 단축 URL

### 상대 URL

상대경로와 절대경로처럼, URL도 상대 URL과 절대 URL로 나뉩니다. 지금까지 이 글에서 다뤘던 것들은
절대 URL입니다. 리소스에 접근하는데 필요한 모든 정보를 가지고 있습니다. 반면에 상대 URL은
모든 정보를 담고 있지 않습니다. 상대 URL로 리소스에 접근하는데 필요한 모든 정보를 얻기 위해서는,
기저(base) URL을 사용해야 합니다.

현재 글에서 상대 URL인 [./http-01](./http-01)을 요청한다고 해봅시다.
현재 보고 계신 글의 절대 URL이자 ./http-01의 기저 URL은 https://www.timegambit.com/blog/http-02 입니다.
`./http-01`만으로는 스킴이나 호스트를 알 수 없습니다. 기저 URL을 사용하면 스킴은 `https`이고,
호스트는 `www.timegambit.com`이라는 것, 추가적인 경로는 `/blog` 라는 것을 추측할 수 있습니다.
기저 URL과 상대 URL을 이용해 다음과 같은 방법으로 새로운 절대 URL을 얻을 수 있습니다.

![상대 URL을 절대 URL로 변환](https://i.imgur.com/iuOjH6k.png)

### 기저 URL

변환 과정의 첫 단계는 기저 URL을 찾는 것입니다. 기저 URL은 상대 URL의 기준이 되기 때문입니다.
기저 URL을 가져오는 몇 가지 방법이 있습니다.

#### 리소스에서 명시적으로 제공

`base` 태그를 이용해 기저 URL을 명시적으로 기술할 수 있습니다.

```html
<head>
  <base href="https://www.timegambit.com/">
</head>

<body>
  <a href="blog">모든 포스트</a>
</body>
```

`a`태그는 `base` 태그의 절대 URL을 이용해 https://www.timegambit.com/blog 라는 새로운 절대 URL을 만들 수 있습니다.

#### 리소스를 포함하고 있는 거지 URL

기저 URL이 명시되지 않은 리소스에 상대 URL이 포함된 경우, 해당 리소스의 URL을 기저 URL로 쓸 수 있습니다.
위에서 본 것처럼요.

#### 기저 URL이 없는 경우

기저 URL이 없는 경우도 있습니다. 보토 ㅇ이런 경우는 절대 URL만으로 이루어져 있다는 뜻입니다.
간혹 불완전하거나 깨진 URL일 수도 있습니다.

### URL 확장

어떤 브라우저들은 URL을 입력한 다음이나 입력하고 있는 동안에 자동으로 URL을 확장합니다.
이 기능은 사용자가 URL 전체를 입력하지 않아도 자동으로 확장시켜주어, URL을 빠르게 입력하는 것을 도와줍니다.

#### 호스트 명 확장

URL 창에 timegambit.com만 쳐도 제 블로그에 접속할 수 있습니다. 접속하신 후에 URL창에서 주소를
복사, 붙여넣기를 해보시면 timegambit.com은 ht<span>tps:/w</span>ww.timegambit.com으로 바뀌어 있습니다.
이는 크롬 브라우저가 timegambit.com에 `https`와 `www`를 붙여서 자동으로 확장시켜 준 것입니다.

#### 히스토리 확장

저의 경우 URL 창에 `g`만 입력해도 `github.com`으로, `go`만 입력해도 `google.com`으로 확장됩니다.
사용자가 URL을 입력하는 시간을 줄이고자, 브라우저가 사용하는 또 다른 기술은 과거에 사용자가 방문했던 URL의 기록을 저장해 놓는 것입니다.
입력된 URL의 앞 글자들을 포함하는 완결된 형태의 URL들을 선택하게 해줌으로써, 사용자는 전체 URL을 입력하는 대신
선택만 하면 됩니다.

#### 주의

프락시를 사용할 경우 URL 자동확장 기능은 다르게 동작할 수 있습니다. 이는 추후에 더욱 자세히 다루도록 하겠습니다.

## 안전하지 않은 문자

URL은 잘 호환되도록 설계되었습니다. URL으로 인터넷의 모든 리소스가 여러 프로토콜을 통해서 잘 전달될 수 있도록, 모든 리소스들에 유일한 이름을
지을 수 있게 설계되었습니다. 어떤 인터넷 프로토콜을 통해서든 안전하게 전송될 수 있도록 URL은 설계되었습니다.

1. ht<span>tps://w</span>ww.abc가나다.com
2. ht<span>tps://w</span>ww.abc라마바.com

예를들어 위와 같은 2개의 다른 사이트가 있다고 해봅시다. 그런데 URL의 설계상 한글을 허용하지 않아서,
URL에 한글이 존재한다면 URL에서 제거된다고 해보겠습니다. 그렇다면 1번과 2번 모두 `https://www.abc.com`이 됩니다.
분명 다른 사이트인데 같은 URL을 가지게 됩니다. 한글이 제거되는 URL 설계로는 모든 리소스들에게
유일한 이름을 지어줄 수가 없습니다. URL에 이진 데이터나 일반적으로 안전한 알파벳 외의 문자를 포함하는 경우를
위한 설계가 필요했습니다. 그래서 이스케이프라는 기능을 추가하여, 안전하지 않은 문자를 안전한 문자로 인코딩할 수 있게 하였습니다.

### 인코딩 체계

```js
console.log(decodeURI('%EA%B5%AC%EA%B8%80'));

// result
'구글'
```

구글에 '구글'을 검색하면 URL에 '%EA%B5%AC%EA%B8%80'과 같은 문자열을 볼 수 있습니다. 이는 '구글'이 안전한 문자열로 인코딩된 것입니다.
중간에 '%'가 많이 보이시죠? 인코딩은 안전하지 않은 문자를 '%' 기호로 시작하여, ASCII 코드로 표현되는 2개의 16진수 숫자로 이루어진
`이스케이프` 문자로 바꿔줍니다.

### 문자 제한

몇몇 문자는 특별한 의미로 예약되어 있어서 사용할 수 없습니다. 굳이 사용하고 싶다면, 그 전에 반드시
인코딩해야 합니다. (그냥 쓰지 마세요!)

|문자|선점 및 제한|
|---|---|
|%|인코딩된 문자에 사용할 이스케이프 토큰으로 선점|
|/|경로 컴포넌트에 있는 경로 세그먼트를 나누는 용도로 선점|
|.|경로 컴포넌트에서 선점|
|..|경로 컴포넌트에서 선점|
|#|프래그먼트의 구획 문자로 선점|
|?|질의 문자열의 구획 문자로 선점|
|;|파라미터의 구획 문자로 선점|
|:|스킴, 사용자 이름/비밀번호, 호스트/포트의 구획 문자로 선점|
|$,+|선점|
|@&=|특정 스킴에서 특별한 의미가 있기 때문에 선점|
|\{}\|\\.~\[]`|게이트웨이와 같은 여러 전송 에이전트에서 불안전하게 다루기 때문에 제한됩니다|
|\<>"|URL 범위 밖에서 역할이 있는 문자이기 때문에 반드시 인코딩해야 합니다.|
|0x00-0x1F, 0x7F|인쇄되지 않는 US-ASCII 문자입니다.|
|0x7F보다 큰 범위|7비트 US-ASCII 문자가 아닙니다.|

### 인코딩 위치

우리는 '구글'을 검색했을 때 '구글'을 인코딩하지 않았습니다. 자동으로 인코딩이 되었습니다. 누가 인코딩을 해준 것일까요?
브라우저가 대신 해준 것입니다. 입력받은 URL에서 어떤 문자를 인코딩해야 하는지 결정하는 데는 브라우저와 같이 사용자로부터 최초로 URL을
입력받는 애플리케이션에서 하는 것이 가장 적절합니다. URL을 구성하는 각 컴포넌트마다 사용할 수 있거나 없는 문자들이 있을 것이고,
또 어떤 문자는 스킴에 따라서 가용성이 달라지기 때문에, 해당 문자들을 직접 입력 받는 애플리케이션인 브라우저야말로
어떤 문자를 인코딩해야 하는지 결정하기에 가장 좋은 위치이기 때문입니다.

## 마치며

지금까지 URI에 대해서 알아보았습니다. 다음 포스트에서는 HTTP 메시지에 대해 알아보겠습니다.
