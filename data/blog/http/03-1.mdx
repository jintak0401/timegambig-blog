---
title: HTTP 메시지(개요 및 메소드) - HTTP 완벽 가이드 3장(1)
date: '2022-12-09'
lastmod: '2022-12-09'
tags: ['HTTP','네트워크']
draft: false
series: HTTP 완벽 가이드
summary: HTTP 완벽 가이드 3장, HTTP 메시지를 정리한 글입니다
images: [https://i.imgur.com/FWceD2q.png]
layout: PostLayout
---

## 메시지의 흐름

![인바운드와 아웃바운드](https://i.imgur.com/YRdwWcJ.png)

AWS를 다루다보면 인바운드/아웃바운드 규칙이라는 것을 볼 수 있습니다.
HTTP 메시지의 방향에 따라서 인바운드, 아웃바운드 용어가 정의됩니다.

* 인바운드: 메시지가 요청할 서버로 향하는 것
* 아웃바운드: 서버에서 처리가 완료된 후 사용자 에이전트로 돌아오는 것

## 메시지의 각 부분

메시지는 **시작줄**, **헤더 블록**, **본문** 이렇게 세 부분으로 이루어집니다.

* 시작줄: 어떤 메시지인지 서술
* 헤더 블록: 메시지에 대한 속성
* 본문: 메시지가 전달하려는 데이터 (없을 수도 있습니다)

### 메시지 문법

```:요청메시지
<메소드> <요청 URL> <버전> // 시작줄
<헤더>

<본문>
```
```:응답메시지
<버전> <상태코드> <사유 구절> // 시작줄
<헤더>

<본문>
```

요청 메시지와 응답 메시지의 형식은 다음과 같습니다. 각 요소에 대해서는 뒤에서 자세히 설명하겠지만,
간단히 요약하여 설명하겠습니다.

* 메소드: 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작으로 'GET', 'POST' 등이 있습니다.
* 요청 URL: 요청 대상이 되는 리소스를 지칭하는 URL
* 버전: 메시지에서 사용중인 HTTP 버전
* 상태코드: 요청을 처리하며 무엇이 일어났는지 설명하는 세 자리 숫자
* 사유 구절: 상태코드를 사람이 어느정도 이해할 수 있도록 풀어서 설명해주는 짧은 문구
* 헤더들: `${이름}: ${값}`과 줄바꿈 문자(CRLF)가 한 줄을 이루어 나타나는 0개 이상의 메시지 속성입니다.
마지막 줄은 빈 줄로 끝나 본문이 시작됨을 알려줍니다.
* 본문: 임의의 데이터 블록으로 없을 수도 있습니다.

### 시작줄

요청 메시지의 시작줄은 서버가 무엇을 해야 하는지, 응답 메시지의 시작줄은 무슨 일이 일어났는지를
말해줍니다.


## 메소드

|메소드|설명|본문 유무|
|---|---|---|
|GET|서버에서 리소스를 가져옵니다|없음|
|HEAD|서버에서 리소스에 대해 헤더만 가져옵니다|없음|
|POST|서버가 처리해야할 데이터를 보냅니다|있음|
|PUT|서버에 요청 메시지의 본문을 저장하거나 수정합니다|있음|
|PATCH|서버의 리소스의 일부분을 요청 메시지의 본문으로 수정합니다|있음|
|TRACE|메시지가 프록시를 거쳐 서버에 도달하는 과정을 추적합니다|없음|
|OPTIONS|서버가 어떤 메소드를 수행할 수 있는지 확인합니다|없음|
|DELETE|서버의 리소스를 제거합니다|없음|

위 표는 HTTP 요청 메소드들을 정리한 표입니다. 하지만 주의해야할 점이 있습니다.
모든 서버가 위의 모든 메소드들을 모두 구현한 것은 아닙니다. 더 나아가서 위 표에 없는 메소드들도 존재할 수 있습니다.
HTTP는 쉽게 확장할 수 있도록 설계되었기 때문에, 어떤 서버들은 그들만의 메소드를 추가로 구현했을 수도
있습니다. 이를 확장 메소드라고 합니다.

<Alert type="warning">

  Q. 서버를 개발할 때, 메소드에 해당하는 동작들을 꼭 설명에 맞게 구현해야 하나요?
  예를들어 GET 메소드에서 다른 메소드의 동작이 일어나면 안되나요?

  A. 반드시 그렇게 구현하길 권장드립니다!

  예를들어 GET 요청이 들어왔을 때 DELETE 동작을 하도록 구현했다고 해보겠습니다. 누군가가
  여러분의 서버에 GET 요청을 보낼 때마다 리소스가 삭제될 수 있습니다! 심지어 검색엔진 크롤러가
  보내온 요청에도 삭제될 수 있습니다! 그렇기 때문에 메소드의 목적에 맞도록 행동들을 구현해야 합니다.
</Alert>

### 안전한 메소드

HTTP는 안전한 메소드라고 불리는 집합을 정의합니다. 안전한 메소드란 HTTP 요청의 결과로 서버에
리소스의 변화가 일어나지 않는 것입니다. 대표적으로 GET, HEAD가 있습니다. GET과 HEAD 요청을 받은
서버는 리소스를 요청한 클라이언트에게 전해주기만 할 뿐, 리소스를 추가, 수정, 삭제하지 않습니다.
반면 POST, PUT, PATCH, DELETE와 같은 메소드들은 리소스를 추가하거나 수정, 삭제를 하기 때문에 안전한
메소드라고 할 수 없습니다.

사실 안전한 메소드가 정말로 추가, 수정, 삭제를 하지 않고 안전한 동작을 한다는 보장은 없습니다.
이는 순전히 웹 개발자에게 달려있습니다. 안전한 메소드의 목적은, 서버에 영향을 줄 수 있는 안전하지
않은 메소드가 사용될 때 사용자들에게 그 사실을 알려주는 HTTP 어플리케이션을 만들 수 있도록 하는 것에 있습니다.

### GET

![블로그 메인 페이지 GET 요청](https://i.imgur.com/MD0stKq.png)

위 사진은 이 블로그 메인페이지에 GET 요청을 보낸 것을 캡쳐한 사진입니다.
이처럼 GET 메소드는 서버에게 리소스를 달라고 요청하기 위해 쓰이는 메소드로, HTTP/1.1은 서버가 이
메소드를 구현할 것을 요구합니다.

#### GET 특징

* 멱등성^[멱등하다라는 것은 동일한 요청을 한 번 보내는 것과 여러 번 보내는 것이 모두 동일한 효과를 지니고,
서버의 상태(리소스의 유무 및 개수 등)도 동일하게 남는 것을 의미합니다.]: 멱등합니다. 단순히 데이터를
가져오는 것이므로 서버의 상태가 바뀌지 않습니다.

### HEAD

![블로그 메인 페이지 HEAD 요청](https://i.imgur.com/M92cHHI.png)

위 사진은 블로그 메인페이지에 HEAD 요청을 보낸 것을 캡쳐한 사진입니다. GET 요청을 보냈을 때와
다르게 본문 영역에 `<Response body is empty>`가 있는 것이 보이시나요?
HEAD 메소드는 GET처럼 동작하지만, 서버는 응답으로 헤더만 돌려줍니다. 본문은 반환되지 않습니다.

### POST

POST 메소드는 서버로 전송한 데이터를 이용해 새로운 리소스를 만들어달라고 요청할 때 쓰이는 메소드입니다.

#### POST 특징

* 식별자^[여기서의 식별자란 `/users/{식별자}`를 이야기합니다.]: 없습니다. POST는 특정한 하나의 리소스를
가리켜 수행되는 메소드가 아니므로 없습니다.

* 멱등성: 멱등하지 않습니다. 동일한 데이터를 담아 POST 요청을
보낼 때마다 새로운 리소스가 생성될 수 있습니다.(무조건 생성된다는 뜻은 아닙니다. 이 부분은 개발자가
구현하기 나름입니다.)

* 캐싱: [RFC7231 명세](https://www.rfc-editor.org/rfc/rfc7231#section-4.3.3)에 따르면
 만료에 대해 헤더에 올바르게 명시되어 있다면 캐싱할 수 있다고 합니다. 다만 POST에 대한 캐싱이
널리 사용되지는 않습니다.

### PUT

PUT 메소드는 요청 URL에 해당하는 리소스가 서버에 존재하지 않을 경우 본문의 데이터로 새로 생성하며,
이미 존재할 경우 본문의 데이터로 **모두 덮어씁니다**. 전자는 POST와 동일하게 동작하여 알기 쉽지만,
후자의 모두 덮어쓴다는 의미는 잘 짚어주고 갈 필요가 있습니다.

예를 들어 서버에 `/users/1`에 `{ name: 'Time Gambit', gender: 'M' }` 이라는 데이터가 있다고
해봅시다.

```:case1
PUT /users/1
{
  name: 'jintak',
  gender: 'F'
}


// 요청 반영 후 /users/1
{
  name: 'jintak',
  gender: 'F'
}
```

```:case2
PUT /users/1
{
  name: 'jintak',
}


// 요청 반영 후 /users/1
{
  name: 'jintak',
  gender: null
}
```

case1에서는 name과 gender를 모두 넣어 요청을 보냈으며 case2에서는 name만 넣어 요청을 보냈습니다.
case1은 name과 gender가 본문의 데이터로 모두 올바르게 바뀌었습니다. 반면 case2의 요청 본문에
gender가 없기 때문에 요청 반영 후에도 gender가 null인 모습을 볼 수 있습니다. 즉, PUT 요청을
보낼 때에는 반영되어야할 모든 데이터를 다 함께 보내주어야 합니다.

#### PUT 특징

* 식별자: 있습니다. 리소스 하나를 가리켜 존재하는지 존재하지 않는지 알아야하므로 식별자가 필요합니다.

* 멱등성: 멱등합니다. 위에서 설명한 바와 같이, 없을 경우와 있을 경우 모두 요청에 있는 데이터로
생성되거나 바뀌기 때문에 요청할 때마다 동일한 결과를 얻을 수 있습니다.

* 캐싱: 캐싱되지 않습니다.

### PATCH

이미 존재하는 리소스를 **부분적으로 수정**할 때 사용되는 메소드입니다. [RFC 5789](https://www.rfc-editor.org/rfc/rfc5789)에
따르면 요청 URL에 해당하는 리소스가 없을 경우 새 리소스가 생성되기는 하지만, 이는 어디까지나 부수효과(side effect)라고
설명하고 있습니다.

마찬가지로 서버에 `/users/1`에 `{ name: 'Time Gambit', gender: 'M' }` 이라는 데이터가 있다고
해봅시다.

```
PATCH /users/1
{
  name: 'jintak',
}


// 요청 반영 후 /users/1
{
  name: 'jintak',
  gender: 'M'
}
```

PUT과는 다르게 부분적으로 수정하므로 데이터에 포함된 name만 수정하며 gender는 그대로 있는 것을
알 수 있습니다.

#### PATCH 특징

* 식별자: 있습니다. 부분적으로 수정할 리소스를 가리켜야하므로 식별자가 필요합니다.

* 멱등성: 멱등하지 않습니다. 멱등하도록 설계할 수 있지만 `{ operation: 'add', num: 10 }`과 같이
데이터를 보내 기존 숫자의 10씩 더하라고 요청하도록 설계할 수 있습니다. 이럴 경우 멱등하지 않게됩니다.

* 캐싱: 캐싱할 수 없습니다.

### POST vs PUT vs PATCH

![POST, PUT, PATCH](https://i.imgur.com/bfLcIjG.png)

POST, PUT, PATCH는 리소스를 추가하거나 삭제한다는 점에서 비슷한 메소드들이라 헷갈리는 때가 많습니다.
그래서 따로 차이점을 정리하였습니다.

|메소드|설명|식별자|멱등성|캐싱|
|---|---|:---:|:---:|:---:|
|POST|새로운 리소스 생성|X|X|O|
|PUT|해당 리소스가 없다면 새로 생성, 있을 경우 모두 덮어쓰기|O|O|X|
|PATCH|해당 리소스를 부분적으로 수정|O|X|X|

### DELETE

서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청할 때 사용되는 메소드입니다.

#### DELETE 특징

* 식별자: 있습니다. 삭제할 리소스를 본문에 담아 요청하지 않고 요청 URL을 통해 전달해야하므로 필요합니다.

* 멱등성: 멱등합니다. 한 번을 요청하든 여러 번을 요청하든 리소스가 삭제된 상태로 동일하므로 멱등합니다.

* 캐싱: 캐싱할 수 없습니다.

## 마치며

생각보다 꽤 길어서 3장은 2번에 걸쳐 정리합니다. 다음 포스트에서는 상태코드들과 헤더에 대해
좀 더 알아보도록 하겠습니다.