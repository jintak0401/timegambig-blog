---
title: '[JavaScript] 배열 생성 방법 속도 비교'
date: '2024-01-27'
lastmod: '2024-01-27'
tags: ['JavaScript','배열']
series: 자바스크립트와 맞짱 뜨기
summary: 'Array.from({ length: N }), Array.from(Array(N)), [...Array(N)] 세 가지 방법으로 배열을 생성하는 방법의 속도를 비교해보았습니다.'
images: [https://i.imgur.com/dcdnIXt.png]
layout: PostLayout
---

## 이 글을 쓰게 된 계기

회사에서 일을 하다보니 바빠서 블로그에 글을 요즘 못 썼습니다. 그래서 오랜만에 다시 시작할겸 어렵거나 복잡한 주제보다는 그냥 흥미 위주의 주제로 글을 써보려고 합니다.

이전에 [\[V8\] Array.from 동작원리](https://www.timegambit.com/blog/digging/v8/array-from)라는 글을 쓴 적이 있습니다.
그 때 배열을 생성하는 여러 방법들마다 얼마나 시간이 차이날지 궁금해서 시간을 측정하고 그래프를 그렸었는데, 이 글은 그 결과에 대한 글입니다.
무언가 큰 정보를 얻으려고하기보다는 그냥 재미로 보시면 될 것 같습니다. 🙂

## 테스트 방법 및 환경

### 방법

```js
const result = [];

for (let N = 1; N <= 10 ** 8; N++) {

  const start = performance.now(); // 측정 시작

  const array = ... // 이 곳에 각 다른 방법으로 배열을 생성해주었습니다.

  const end = performance.now(); // 측정 종료

  result.push(end - start);

}
```

총 3가지 방법을 비교해보았습니다.

- [Array.from(\{ length: N })](#arrayfrom-length-n-)
- [Array.from(Array(N))](#arrayfromarrayn)
- [\[...Array(N)\]](#arrayn)

### 환경

- Memory: 32GB
- Node.js: v18.18.2
- etc: 컴퓨터 부팅 직후에 각 방법들을 테스트했으며, 테스트를 진행하는 동안 테스트 이외의 다른 작업은 하지 않았습니다.

## Array.from(\{ length: N })

### 그래프

![총 생성 시간](https://i.imgur.com/xovR4VNh.png)

![1000개당 생성 시간](https://i.imgur.com/otvV7PNh.png)

### 그래프를 보며 느낀점

- 0.32 부근과 0.5 부근에서 시간이 확 증가한다.
- 0 ~ 0.32(A), 0.3 ~ 0.5(B), 0.5 ~ 1.0(C)에서 총 생성 시간이 선형적으로 증가한다.
- 구간 A에서는 개당 생성 시간이 거의 동일하게 유지되다가 B, C에서는 개당 생성 시간이 감소한다.
- 0.5 와 1.0 일 때 배열 길이가 2배가 차이남에도 불구하고 개당 생성 시간이 거의 동일하다.

## Array.from(Array(N))

### 그래프

![총 생성 시간](https://i.imgur.com/UH68qV8h.png)

![1000개당 생성 시간](https://i.imgur.com/MgFKT1Nh.png)

### 그래프를 보며 느낀 생각

- [Array.from(\{ length: N })](#arrayfrom-length-n-) 보다 시간이 확 증가하는 구간이 많다.
- 각 구간에서 총 생성 시간이 선형적으로 증가한다.
- 개당 생성 시간이 증가하고 감소하는 양상이 처음부터 반복된다.
- 0.58 부근 이전의 각 구간에서 생성 시간이 큰 폭으로 진동하지만, 0.58 이후의 구간에서는 진동 폭이 작아진다.
- 0.32 부근 이후의 구간부터 각 구간의 개당 생성 시간이 가장 높을 때의 수치가 비슷하며 가장 적을 때의 수치도 비슷하다.

## \[...Array(N)]

### 그래프

![총 생성 시간](https://i.imgur.com/QKw1MmTh.png)

![1000개당 생성 시간](https://i.imgur.com/wm7MM5Th.png)

### 그래프를 보며 느낀점

- 다른 그래프들과 마찬가지로 시간의 확 증가하는 구간이 있다.
- 각 구간에서 총 생성 시간이 선형적으로 증가한다.
- 0.32 부근 이전의 구간까지 개당 생성 시간이 거의 동일하다가 0.32 에서 확 증가하고 특정 주기로 증가하고 감소하는 양상이 반복되는 것이 [Array.from(\{ length: N })](#arrayfrom-length-n-) 과 비슷하다.
- 0.32 ~ 0.43, 0.43 ~ 0.7 구간에서는 생성 시간이 큰 폭으로 진동하다가 후반부에 거의 진동하지 않는다. 0.7 이후 구간에서는 거의 진동하지 않는다.
- 0.32 부근 이후의 구간부터 각 구간의 개당 생성 시간이 가장 높을 때의 수치가 비슷하며 가장 적을 때의 수치도 비슷하다.

## 전체 비교

### 그래프

![총 생성 시간](https://i.imgur.com/Wga7Cqyh.png)

![1000개당 생성 시간](https://i.imgur.com/MeKul0vh.png)

### 그래프를 보며 느낀점

- 0.32 까지는 `Array.from({ length: N })`, `Array.from(Array(N))`, `[...Array(N)]` 순으로 시간이 많이 걸리다가, 0.32 부근부터 `Array.from({ length: N })`, `[...Array(N)]`, `Array.from(Array(N))` 순으로 시간이 많이 걸린다.
- 0.32 부근을 제외한 시간이 확 증가하는 포인트가 각 방법마다 다르다.
- 0.32 이전까지 `Array.from({ length: N })`과 `[...Array(N)]`의 양상은 비슷하다. 하지만 `[...Array(N)]` 의 진동 빈도가 더 높다.
- 0.32 이전까지 `Array.from(Array(N))`의 양상은 증가와 반복의 구간이 여럿 존재한다는 점에서 다른 방법들과 확연히 차이난다.
- 0.32 이후의 양상은 세 방법 다 비슷하다.

## 마치며

나름 재밌는 분석이었습니다. 특히 0.32 부근에서 동일하게 시간이 증가하지만 그 이후에는 각자 다른 포인트에서 시간이 증가한다는 점, 개당 생성 시간이 거의 비슷한
최고 수치(`Array.from({ length: N })`은 좀 다르지만...)부터 비슷한 최저 수치까지 감소되는 양상이 반복된다는 점이 흥미로웠습니다.

데이터 수집을 한 후 생각을 해봤는데 조금 잘못된 방식으로 테스트를 진행한건가 싶기도 합니다. 제 생각의 흐름을 적어보자면,

1. 자바스크립트는 내부적으로 배열도 객체로 관리하지 않나?
2. 그러면 배열을 할당할 때에 내부적으로 배열의 길이보다 큰 해시테이블을 할당하지 않을까?
3. 그런데 이 테스트 방법이라면 이번에 할당해야할 배열 크기가 이전 for문 사이클에서 할당된 해시테이블을 그대로 사용해도될 정도의 크기라면, 이전 사이클의 메모리할당에 영향을 받는게 아닐까?

이런 생각이 들었거든요. 하지만 이 분석의 목적은 단순 호기심 충족이기 때문에 이 정도로만 하고 넘어가려고 합니다. 🙃
